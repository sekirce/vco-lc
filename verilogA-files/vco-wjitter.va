// VerilogA for wk_anthimosg2, vco_model, veriloga
// vmsUpdateCellViews(?lib "elta_VCO_aleksandarv" ?cell "vco_va_model" ?view "veriloga")

`include "constants.vams"
`include "disciplines.vams"

//
// Differential quadrature voltage controlled oscillator
// output is square wave with white accumulating jitter
//

module vco_va_model (PIout,NIout, PQout,NQout, Ptunein,Ntunein, Vbbias);

input Ptunein, Ntunein, Vbbias; voltage Ptunein, Ntunein, Vbbias;		// input terminals added Vbbias
output PIout, NIout; voltage PIout, NIout;      					// output terminals
output PQout, NQout; voltage PQout, NQout;      					// output terminals
parameter real vmin=0;                          					// input voltage that corresponds to minimum output frequency
parameter real vmax=vmin+1 from (vmin:inf);     					// input voltage that corresponds to maximum output frequency
parameter real vbbias_min = 1.2;									// input voltage bias that corresponds to minimum amplitude
parameter real vbbias_max = 1.8;									// input voltage bias that corresponds to maximum amplitude
parameter real fmin=1 from (0:inf);             					// minimum output frequency
parameter real fmax=2*fmin from (fmin:inf);     					// maximum output frequency
parameter real vl=-1;                           					// high output voltage
parameter real vh=1;                            					// low output voltage
parameter real tt=0.01/fmax from (0:inf);       					// output transition time
parameter real ttol=1u/fmax from (0:0.1/fmax);  					// time tolerance
parameter real jitter=0 from [0:0.25/fmax);     					// period jitter (produces white accumulating jitter)
real freq, phase, dT, kvco, kvcoex;
integer i, q, seed;

analog begin
    @(initial_step) seed = 133;

    // compute the freq from the input voltage - linear
    // freq = (V(Ptunein,Ntunein) - vmin) * (fmax - fmin) / (vmax - vmin) + fmin;
	kvco = (fmax - fmin) / (vmax - vmin);
	kvcoex =0.035∗kvco∗exp(V(Ptunein,Ntunein));

	freq=V(Ptunein,Ntunein)*kvcoex+ fmin;

    // bound the frequency (this is optional)
    if (freq > fmax) freq = fmax;
    if (freq < fmin) freq = fmin;

    // add the phase noise
    freq = freq/(1 + dT*freq);

    // bound the time step to assure no cycles are skipped
    $bound_step(0.6/freq);

    // phase is the integral of the freq modulo 2 pi
    phase = 2*`M_PI*idtmod(freq, 0.0, 1.0, -0.5);

    // update jitter where phase crosses p/2
    // 2=sqrt(K), K=4 jitter updates per period
    @(cross(phase - 3*`M_PI/4, +1, ttol) or cross(phase - `M_PI/4, +1, ttol) or
    cross(phase + `M_PI/4, +1, ttol) or cross(phase + 3*`M_PI/4, +1, ttol)) begin
        dT = 2*jitter*$rdist_normal(seed,0,1);
        i = (phase >= -3*`M_PI/4) && (phase < `M_PI/4);
        q = (phase >= -`M_PI/4) && (phase < 3*`M_PI/4);
    end

    // generate the I and Q outputs
    V(PIout) <+ transition(i ? vh : vl, 0, tt);
    V(NIout) <+ transition(i ? vl : vh, 0, tt);
    V(PQout) <+ transition(q ? vh : vl, 0, tt);
    V(NQout) <+ transition(q ? vl : vh, 0, tt);
end
endmodule